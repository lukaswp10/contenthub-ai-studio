import { test, expect } from '@playwright/test';
import { E2E_CONFIG } from '../config/test-config';

test.describe('üé¨ ClipsForge - Editor Funcional', () => {
  
  // Helper para fazer login
  const loginUser = async (page: any) => {
    await page.goto(`${E2E_CONFIG.urls.base}/login`);
    await page.waitForLoadState('networkidle');
    
    await page.fill('input[type="email"]', 'lukaswp10@gmail.com');
    await page.fill('input[type="password"]', '7pguyrxV!');
    await page.waitForSelector('form button[type="submit"]:not([disabled])', { timeout: 15000 });
    await page.click('form button[type="submit"]');
    
    await page.waitForLoadState('networkidle', { timeout: 60000 });
    await page.waitForTimeout(3000);
  };

  // Helper para ir ao editor
  const goToEditor = async (page: any) => {
    await loginUser(page);
    
    // Tentar via bot√£o "Editor Manual"
    const editorButton = page.locator('button:has-text("Editor Manual")');
    if (await editorButton.count() > 0) {
      await page.evaluate(() => {
        const buttons = Array.from(document.querySelectorAll('button'));
        const button = buttons.find(btn => btn.textContent?.includes('Editor Manual'));
        if (button) {
          button.click();
        }
      });
      await page.waitForLoadState('networkidle');
    } else {
      // Navega√ß√£o direta
      await page.goto(`${E2E_CONFIG.urls.base}/editor`);
      await page.waitForLoadState('networkidle');
    }
    
    const editorUrl = page.url();
    expect(editorUrl).toContain('/editor');
    await page.waitForTimeout(3000);
  };

  test('Controles de reprodu√ß√£o (Play/Pause)', async ({ page }) => {
    console.log('‚ñ∂Ô∏è Testando controles de reprodu√ß√£o...');
    
    await goToEditor(page);
    
    // Verificar se h√° player de v√≠deo
    const videoPlayer = page.locator('video');
    const hasVideo = await videoPlayer.count() > 0;
    
    if (hasVideo) {
      console.log('üìπ Player de v√≠deo encontrado');
      
      // Verificar controles b√°sicos
      const playButton = page.locator('button:has([data-testid="play-icon"]), button:has-text("‚ñ∂"), button:has-text("Play")');
      const pauseButton = page.locator('button:has([data-testid="pause-icon"]), button:has-text("‚è∏"), button:has-text("Pause")');
      
      // Testar bot√£o Play
      if (await playButton.count() > 0) {
        console.log('‚ñ∂Ô∏è Bot√£o Play encontrado');
        await playButton.first().click();
        await page.waitForTimeout(2000);
        
        // Verificar se v√≠deo est√° reproduzindo
        const isPlaying = await videoPlayer.first().evaluate((video: HTMLVideoElement) => {
          return !video.paused && !video.ended && video.readyState > 2;
        });
        
        if (isPlaying) {
          console.log('‚úÖ V√≠deo est√° reproduzindo');
        } else {
          console.log('‚ö†Ô∏è V√≠deo pode n√£o estar reproduzindo');
        }
        
        // Testar bot√£o Pause
        if (await pauseButton.count() > 0) {
          console.log('‚è∏Ô∏è Bot√£o Pause encontrado');
          await pauseButton.first().click();
          await page.waitForTimeout(1000);
          
          const isPaused = await videoPlayer.first().evaluate((video: HTMLVideoElement) => {
            return video.paused;
          });
          
          if (isPaused) {
            console.log('‚úÖ V√≠deo pausado com sucesso');
          } else {
            console.log('‚ö†Ô∏è V√≠deo pode n√£o ter pausado');
          }
        } else {
          console.log('‚ö†Ô∏è Bot√£o Pause n√£o encontrado');
        }
      } else {
        console.log('‚ö†Ô∏è Bot√£o Play n√£o encontrado');
      }
    } else {
      console.log('‚ö†Ô∏è Player de v√≠deo n√£o encontrado - testando sem v√≠deo');
      
      // Verificar se h√° controles mesmo sem v√≠deo
      const controls = page.locator('button:has-text("‚ñ∂"), button:has-text("Play")');
      if (await controls.count() > 0) {
        console.log('üéÆ Controles encontrados mesmo sem v√≠deo');
        await controls.first().click();
        console.log('‚úÖ Controle clicado (sem v√≠deo)');
      }
    }
    
    console.log('‚úÖ Teste de controles de reprodu√ß√£o conclu√≠do!');
  });

  test('Timeline e navega√ß√£o temporal', async ({ page }) => {
    console.log('‚è±Ô∏è Testando timeline e navega√ß√£o temporal...');
    
    await goToEditor(page);
    
    // Procurar timeline
    const timelineSelectors = [
      '[data-testid="timeline"]',
      '.timeline',
      'div:has-text("Timeline")',
      'input[type="range"]'
    ];
    
    let timeline = null;
    for (const selector of timelineSelectors) {
      const element = page.locator(selector);
      if (await element.count() > 0) {
        timeline = element;
        console.log(`‚è±Ô∏è Timeline encontrada: ${selector}`);
        break;
      }
    }
    
    if (timeline) {
      // Testar clique na timeline
      await timeline.first().click();
      await page.waitForTimeout(1000);
      console.log('‚úÖ Timeline clicada');
      
      // Verificar se h√° indicador de tempo
      const timeIndicators = page.locator('text=/\\d+:\\d+/, text=/\\d+\\.\\d+s/, text=/\\d+s/');
      if (await timeIndicators.count() > 0) {
        console.log('‚è∞ Indicadores de tempo encontrados');
      } else {
        console.log('‚ö†Ô∏è Indicadores de tempo n√£o encontrados');
      }
      
      // Testar navega√ß√£o com teclado
      await page.keyboard.press('ArrowRight');
      await page.waitForTimeout(500);
      await page.keyboard.press('ArrowLeft');
      await page.waitForTimeout(500);
      console.log('‚å®Ô∏è Navega√ß√£o com teclado testada');
      
    } else {
      console.log('‚ö†Ô∏è Timeline n√£o encontrada');
    }
    
    console.log('‚úÖ Teste de timeline conclu√≠do!');
  });

  test('Funcionalidade de corte/divis√£o', async ({ page }) => {
    console.log('‚úÇÔ∏è Testando funcionalidade de corte...');
    
    await goToEditor(page);
    
    // Procurar bot√µes de corte
    const cutButtons = [
      'button:has-text("‚úÇ")',
      'button:has-text("Cortar")',
      'button:has-text("Dividir")',
      'button:has-text("Split")',
      '[data-testid="cut-button"]'
    ];
    
    let cutButton = null;
    for (const selector of cutButtons) {
      const element = page.locator(selector);
      if (await element.count() > 0) {
        cutButton = element;
        console.log(`‚úÇÔ∏è Bot√£o de corte encontrado: ${selector}`);
        break;
      }
    }
    
    if (cutButton) {
      // Testar clique no bot√£o de corte
      await cutButton.first().click();
      await page.waitForTimeout(2000);
      console.log('‚úÖ Bot√£o de corte clicado');
      
      // Verificar se apareceu algum feedback visual
      const feedbackSelectors = [
        'text="Corte realizado"',
        'text="V√≠deo dividido"',
        'text="Split aplicado"',
        '.cut-indicator',
        '.split-marker'
      ];
      
      let feedbackFound = false;
      for (const selector of feedbackSelectors) {
        if (await page.locator(selector).count() > 0) {
          console.log(`‚úÖ Feedback de corte encontrado: ${selector}`);
          feedbackFound = true;
          break;
        }
      }
      
      if (!feedbackFound) {
        console.log('‚ö†Ô∏è Feedback visual de corte n√£o encontrado');
      }
      
      // Testar atalho de teclado para corte
      await page.keyboard.press('Space'); // Pausar se estiver reproduzindo
      await page.waitForTimeout(500);
      await page.keyboard.press('Control+K'); // Atalho comum para corte
      await page.waitForTimeout(1000);
      console.log('‚å®Ô∏è Atalho de corte testado (Ctrl+K)');
      
    } else {
      console.log('‚ö†Ô∏è Bot√£o de corte n√£o encontrado');
    }
    
    console.log('‚úÖ Teste de funcionalidade de corte conclu√≠do!');
  });

  test('Zoom e visualiza√ß√£o da timeline', async ({ page }) => {
    console.log('üîç Testando zoom e visualiza√ß√£o...');
    
    await goToEditor(page);
    
    // Procurar controles de zoom
    const zoomControls = [
      'button:has-text("+")',
      'button:has-text("-")',
      'button:has-text("Zoom In")',
      'button:has-text("Zoom Out")',
      '[data-testid="zoom-in"]',
      '[data-testid="zoom-out"]'
    ];
    
    let zoomInButton = null;
    let zoomOutButton = null;
    
    for (const selector of zoomControls) {
      const element = page.locator(selector);
      if (await element.count() > 0) {
        if (selector.includes('+') || selector.includes('In')) {
          zoomInButton = element;
          console.log(`üîç Bot√£o Zoom In encontrado: ${selector}`);
        } else if (selector.includes('-') || selector.includes('Out')) {
          zoomOutButton = element;
          console.log(`üîç Bot√£o Zoom Out encontrado: ${selector}`);
        }
      }
    }
    
    // Testar zoom in
    if (zoomInButton) {
      await zoomInButton.first().click();
      await page.waitForTimeout(1000);
      console.log('‚úÖ Zoom In testado');
    }
    
    // Testar zoom out
    if (zoomOutButton) {
      await zoomOutButton.first().click();
      await page.waitForTimeout(1000);
      console.log('‚úÖ Zoom Out testado');
    }
    
    // Testar zoom com scroll
    const timeline = page.locator('[data-testid="timeline"], .timeline').first();
    if (await timeline.count() > 0) {
      await timeline.hover();
      await page.mouse.wheel(0, -100); // Scroll up
      await page.waitForTimeout(500);
      await page.mouse.wheel(0, 100); // Scroll down
      await page.waitForTimeout(500);
      console.log('üñ±Ô∏è Zoom com scroll testado');
    }
    
    // Testar atalhos de zoom
    await page.keyboard.press('Control+Plus');
    await page.waitForTimeout(500);
    await page.keyboard.press('Control+Minus');
    await page.waitForTimeout(500);
    console.log('‚å®Ô∏è Atalhos de zoom testados');
    
    console.log('‚úÖ Teste de zoom conclu√≠do!');
  });

  test('Atalhos de teclado cr√≠ticos', async ({ page }) => {
    console.log('‚å®Ô∏è Testando atalhos de teclado cr√≠ticos...');
    
    await goToEditor(page);
    
    // Lista de atalhos cr√≠ticos para testar
    const criticalShortcuts = [
      { key: 'Space', description: 'Play/Pause' },
      { key: 'Control+Z', description: 'Undo' },
      { key: 'Control+Y', description: 'Redo' },
      { key: 'Control+S', description: 'Save' },
      { key: 'Delete', description: 'Delete' },
      { key: 'ArrowLeft', description: 'Previous frame' },
      { key: 'ArrowRight', description: 'Next frame' },
      { key: 'Home', description: 'Go to start' },
      { key: 'End', description: 'Go to end' }
    ];
    
    for (const shortcut of criticalShortcuts) {
      try {
        console.log(`‚å®Ô∏è Testando: ${shortcut.key} (${shortcut.description})`);
        await page.keyboard.press(shortcut.key);
        await page.waitForTimeout(500);
        console.log(`‚úÖ ${shortcut.key} executado`);
      } catch (error) {
        console.log(`‚ö†Ô∏è Erro ao testar ${shortcut.key}:`, error);
      }
    }
    
    console.log('‚úÖ Teste de atalhos de teclado conclu√≠do!');
  });

  test('Funcionalidades de sele√ß√£o e edi√ß√£o', async ({ page }) => {
    console.log('üéØ Testando sele√ß√£o e edi√ß√£o...');
    
    await goToEditor(page);
    
    // Procurar elementos selecion√°veis na timeline
    const selectableElements = [
      '.timeline-block',
      '.video-segment',
      '.clip-item',
      '[data-testid="timeline-item"]'
    ];
    
    let elementFound = false;
    for (const selector of selectableElements) {
      const elements = page.locator(selector);
      if (await elements.count() > 0) {
        console.log(`üéØ Elementos selecion√°veis encontrados: ${selector}`);
        
        // Testar clique para sele√ß√£o
        await elements.first().click();
        await page.waitForTimeout(1000);
        console.log('‚úÖ Elemento selecionado');
        
        // Testar sele√ß√£o m√∫ltipla (Ctrl+Click)
        if (await elements.count() > 1) {
          await page.keyboard.down('Control');
          await elements.nth(1).click();
          await page.keyboard.up('Control');
          await page.waitForTimeout(1000);
          console.log('‚úÖ Sele√ß√£o m√∫ltipla testada');
        }
        
        elementFound = true;
        break;
      }
    }
    
    if (!elementFound) {
      console.log('‚ö†Ô∏è Elementos selecion√°veis n√£o encontrados');
    }
    
    // Testar arrastar e soltar
    const draggableElements = page.locator('[draggable="true"], .draggable');
    if (await draggableElements.count() > 0) {
      const element = draggableElements.first();
      const bbox = await element.boundingBox();
      
      if (bbox) {
        await page.mouse.move(bbox.x + bbox.width / 2, bbox.y + bbox.height / 2);
        await page.mouse.down();
        await page.mouse.move(bbox.x + 100, bbox.y);
        await page.mouse.up();
        await page.waitForTimeout(1000);
        console.log('‚úÖ Drag & drop testado');
      }
    }
    
    console.log('‚úÖ Teste de sele√ß√£o e edi√ß√£o conclu√≠do!');
  });

  test('Verifica√ß√£o de performance e responsividade', async ({ page }) => {
    console.log('‚ö° Testando performance e responsividade...');
    
    await goToEditor(page);
    
    // Medir tempo de resposta dos controles
    const startTime = Date.now();
    
    // Testar m√∫ltiplos cliques r√°pidos
    const playButton = page.locator('button:has-text("‚ñ∂"), button:has-text("Play")').first();
    if (await playButton.count() > 0) {
      for (let i = 0; i < 5; i++) {
        await playButton.click();
        await page.waitForTimeout(100);
      }
    }
    
    const responseTime = Date.now() - startTime;
    console.log(`‚ö° Tempo de resposta: ${responseTime}ms`);
    
    // Verificar se interface n√£o travou
    const isResponsive = responseTime < 5000; // 5 segundos limite
    if (isResponsive) {
      console.log('‚úÖ Interface responsiva');
    } else {
      console.log('‚ö†Ô∏è Interface pode estar lenta');
    }
    
    // Testar scroll suave
    await page.evaluate(() => {
      window.scrollTo({ top: 100, behavior: 'smooth' });
    });
    await page.waitForTimeout(1000);
    
    await page.evaluate(() => {
      window.scrollTo({ top: 0, behavior: 'smooth' });
    });
    await page.waitForTimeout(1000);
    
    console.log('‚úÖ Scroll suave testado');
    
    console.log('‚úÖ Teste de performance conclu√≠do!');
  });

}); 