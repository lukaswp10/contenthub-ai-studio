import { serve } from "https://deno.land/std@0.168.0/http/server.ts"
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'
import { v2 as cloudinary } from 'https://esm.sh/cloudinary@1.41.0'

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
}

interface GenerateClipsRequest {
  video_id: string
  clip_suggestions: Array<{
    start_time: number
    end_time: number
    title: string
    viral_score: number
    hook_strength: number
    hashtags: string[]
    reason: string
    topic: string
    emotions: string[]
    best_platforms: string[]
    content_category: string
  }>
  cloudinary_public_id: string
  preferences?: any
}

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders })
  }

  try {
    const authHeader = req.headers.get('Authorization')!
    const supabase = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      { global: { headers: { Authorization: authHeader } } }
    )

    const { data: { user } } = await supabase.auth.getUser()
    if (!user) throw new Error('Não autenticado')

    const { 
      video_id, 
      clip_suggestions, 
      cloudinary_public_id,
      preferences = {}
    }: GenerateClipsRequest = await req.json()

    console.log(`Generating ${clip_suggestions.length} clips for video ${video_id}`)

    // Configure Cloudinary
    cloudinary.config({
      cloud_name: Deno.env.get('CLOUDINARY_CLOUD_NAME'),
      api_key: Deno.env.get('CLOUDINARY_API_KEY'),
      api_secret: Deno.env.get('CLOUDINARY_API_SECRET'),
    })

    // Get video details for watermark info
    const { data: profile } = await supabase
      .from('profiles')
      .select('plan_type')
      .eq('id', user.id)
      .single()

    const addWatermark = profile?.plan_type === 'free' && preferences.addWatermark !== false
    
    const createdClips = []
    const errors = []
    
    // Process clips in batches to avoid overload
    const batchSize = 3
    for (let i = 0; i < clip_suggestions.length; i += batchSize) {
      const batch = clip_suggestions.slice(i, i + batchSize)
      
      await Promise.all(batch.map(async (suggestion, batchIndex) => {
        const clipIndex = i + batchIndex
        
        try {
          console.log(`Processing clip ${clipIndex + 1}/${clip_suggestions.length}: ${suggestion.title}`)
          
          // Calculate duration and validate
          const duration = suggestion.end_time - suggestion.start_time
          if (duration <= 0 || duration > 90) {
            throw new Error(`Invalid clip duration: ${duration}s`)
          }
          
          // Generate unique public_id for the clip
          const clipPublicId = `clips/${user.id}/${video_id}_clip_${clipIndex + 1}_${Date.now()}`
          
          // Build Cloudinary transformations
          const transformations = []
          
          // 1. Extract clip segment
          transformations.push(
            `t_${suggestion.start_time.toFixed(2)}_${suggestion.end_time.toFixed(2)}`  // Trim from start to end
          )
          
          // 2. Optimize for TikTok/Reels (9:16 aspect ratio, high quality)
          if (preferences.optimizeForMobile !== false) {
            transformations.push(
              'c_fill',
              'w_1080',  // Aumentado para melhor qualidade
              'h_1920',  // 9:16 ratio para TikTok
              'g_center',
              'q_auto:best'  // Melhor qualidade
            )
          } else {
            // Keep original aspect ratio but limit size
            transformations.push(
              'c_limit',
              'w_1080',
              'h_1080'
            )
          }
          
          // 3. Add subtitles if requested
          if (preferences.generateSubtitles) {
            transformations.push(
              'l_subtitles:' + cloudinary_public_id.replace(/\//g, ':') + '.srt',
              'g_south',
              'y_50'
            )
          }
          
          // 4. Add watermark for free plan
          if (addWatermark) {
            transformations.push(
              'l_text:Arial_20_bold:ContentHub%20AI',
              'co_rgb:ffffff',
              'o_70',
              'g_south_east',
              'x_10',
              'y_10'
            )
          }
          
          // 5. Audio and quality optimization for TikTok
          transformations.push(
            'q_auto:best',  // Melhor qualidade
            'f_mp4',
            'vc_h264', // Video codec
            'ac_aac',   // Audio codec
            'fl_attachment:clip'  // Força download como arquivo
          )
          
          // Build transformation string
          const transformation = transformations.join(',')
          
          // Generate clip URL
          const clipUrl = cloudinary.url(cloudinary_public_id, {
            resource_type: 'video',
            transformation: transformation,
            secure: true
          })
          
          // Generate thumbnail (middle frame of clip) - CORRIGIDO
          const thumbnailTime = suggestion.start_time + (duration / 2)
          const thumbnailTransformations = [
            `t_${thumbnailTime.toFixed(2)}_${(thumbnailTime + 1).toFixed(2)}`,  // 1 segundo para thumbnail
            'c_fill',
            'w_480',
            'h_720',
            'g_center',
            'q_auto:best',
            'f_jpg'
          ]
          
          const thumbnailUrl = cloudinary.url(cloudinary_public_id, {
            resource_type: 'video',
            transformation: thumbnailTransformations.join(','),
            secure: true
          })
          
          // Generate preview GIF - CORRIGIDO
          const gifTransformations = [
            `t_${suggestion.start_time.toFixed(2)}_${(suggestion.start_time + 3).toFixed(2)}`, // 3 second preview
            'c_fill',
            'w_320',
            'h_480',
            'g_center',
            'q_auto',
            'f_gif',
            'fps_10'
          ]
          
          const previewGifUrl = cloudinary.url(cloudinary_public_id, {
            resource_type: 'video',
            transformation: gifTransformations.join(','),
            secure: true
          })
          
          // Save clip to database
          const { data: clipData, error: clipError } = await supabase
            .from('clips')
            .insert({
              video_id,
              user_id: user.id,
              clip_number: clipIndex + 1,
              title: suggestion.title,
              start_time_seconds: suggestion.start_time,
              end_time_seconds: suggestion.end_time,
              cloudinary_public_id: clipPublicId,
              cloudinary_secure_url: clipUrl,
              thumbnail_url: thumbnailUrl,
              preview_gif_url: previewGifUrl,
              // AI metadata
              ai_viral_score: suggestion.viral_score,
              ai_hook_strength: suggestion.hook_strength,
              ai_best_platform: suggestion.best_platforms,
              ai_detected_emotions: suggestion.emotions,
              ai_content_category: suggestion.content_category,
              ai_analysis_reason: suggestion.reason,
              // SEO
              suggested_title: suggestion.title,
              hashtags: suggestion.hashtags,
              keywords: extractKeywords(suggestion.title + ' ' + suggestion.reason),
              // Status
              status: 'ready'
            })
            .select()
            .single()

          if (clipError) {
            console.error(`Error saving clip ${clipIndex + 1}:`, clipError)
            errors.push({ clip: clipIndex + 1, error: clipError.message })
          } else {
            createdClips.push(clipData)
            console.log(`Clip ${clipIndex + 1} created successfully`)
          }

          // Small delay between clips
          await new Promise(resolve => setTimeout(resolve, 500))

        } catch (clipError: any) {
          console.error(`Error processing clip ${clipIndex + 1}:`, clipError)
          errors.push({ clip: clipIndex + 1, error: clipError.message })
        }
      }))
    }

    // Update video status
    const finalStatus = createdClips.length > 0 ? 'ready' : 'failed'
    const processingEnd = new Date()
    
    const { data: video } = await supabase
      .from('videos')
      .select('processing_started_at')
      .eq('id', video_id)
      .single()
    
    const processingDuration = video?.processing_started_at 
      ? Math.round((processingEnd.getTime() - new Date(video.processing_started_at).getTime()) / 1000)
      : null

    await supabase
      .from('videos')
      .update({ 
        processing_status: finalStatus,
        processing_completed_at: processingEnd.toISOString(),
        processing_duration_seconds: processingDuration
      })
      .eq('id', video_id)

    // Update user clip count
    await supabase.rpc('increment', {
      table_name: 'profiles',
      column_name: 'usage_clips_generated_total',
      row_id: user.id,
      increment_value: createdClips.length
    })

    console.log(`Processing completed: ${createdClips.length}/${clip_suggestions.length} clips created`)

    // Send notification (webhook to notification service)
    await fetch(`${Deno.env.get('SUPABASE_URL')}/functions/v1/send-notification`, {
      method: 'POST',
      headers: {
        'Authorization': authHeader,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        user_id: user.id,
        type: 'processing_complete',
        data: {
          video_id,
          clips_created: createdClips.length,
          processing_duration: processingDuration
        }
      })
    }).catch(console.error)
    
    return new Response(JSON.stringify({
      success: true,
      video_id,
      clips_created: createdClips.length,
      clips_failed: errors.length,
      clips: createdClips,
      errors: errors.length > 0 ? errors : undefined,
      processing_duration_seconds: processingDuration
    }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' }
    })

  } catch (error: any) {
    console.error('Generate clips error:', error)
    
    const { video_id } = await req.json().catch(() => ({}))
    if (video_id) {
      const supabase = createClient(
        Deno.env.get('SUPABASE_URL') ?? '',
        Deno.env.get('SUPABASE_ANON_KEY') ?? ''
      )
      
      await supabase
        .from('videos')
        .update({ 
          processing_status: 'failed',
          error_message: error.message,
          error_details: { 
            step: 'clip_generation',
            error: error.message,
            timestamp: new Date().toISOString()
          }
        })
        .eq('id', video_id)
    }

    return new Response(JSON.stringify({ 
      success: false,
      error: error.message 
    }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' }
    })
  }
})

function extractKeywords(text: string): string[] {
  // Remove common words and extract meaningful keywords
  const stopWords = new Set([
    'a', 'o', 'de', 'da', 'do', 'para', 'com', 'em', 'no', 'na', 'por', 'que', 'e', 'é', 'um', 'uma',
    'the', 'of', 'to', 'and', 'in', 'for', 'with', 'on', 'at', 'by', 'an', 'as', 'or', 'it', 'is'
  ])
  
  const words = text.toLowerCase()
    .replace(/[^\w\s]/g, ' ')
    .split(/\s+/)
    .filter(word => word.length > 3 && !stopWords.has(word))
  
  // Count frequency
  const frequency: Record<string, number> = {}
  words.forEach(word => {
    frequency[word] = (frequency[word] || 0) + 1
  })
  
  // Sort by frequency and return top keywords
  return Object.entries(frequency)
    .sort((a, b) => b[1] - a[1])
    .slice(0, 10)
    .map(([word]) => word)
} 