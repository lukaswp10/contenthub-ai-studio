// Utilit√°rio para gerenciar persist√™ncia da galeria de v√≠deos (100% SUPABASE)
import { supabase } from '../lib/supabase'

export interface GalleryVideo {
  id: string
  name: string
  thumbnail: string
  duration: number
  size: string
  uploadedAt: Date
  file?: File
  url?: string
  cloudinaryPublicId?: string // ID do v√≠deo no Cloudinary
  cloudinaryUrl?: string // URL permanente do Cloudinary
  transcription?: { // ‚úÖ NOVO: Suporte para transcri√ß√£o persistente
    words: TranscriptionWord[]
    text: string
    language?: string
    confidence?: number
    provider?: 'whisper' | 'assemblyai' | 'webspeech'
    createdAt?: string
  }
  // ‚úÖ NOVO: Sistema de legendas originais vs editadas
  captions?: {
    original: TranscriptionWord[] // Legendas originais da transcri√ß√£o
    edited: TranscriptionWord[] // Legendas editadas pelo usu√°rio
    hasEdits: boolean // Se tem edi√ß√µes feitas
    lastEditedAt?: string // Quando foi editado pela √∫ltima vez
  }
}

// ‚úÖ NOVA INTERFACE: Palavra de transcri√ß√£o
export interface TranscriptionWord {
  text: string
  start: number
  end: number
  confidence: number
  highlight?: boolean
  speaker?: string
}

export interface GalleryClip {
  id: string
  name: string
  thumbnail: string
  duration: number
  format: 'TikTok' | 'Instagram' | 'YouTube'
  createdAt: Date
  status: 'processing' | 'ready' | 'error'
}

// ‚úÖ Fun√ß√£o para salvar v√≠deo no Supabase (100% REAL)
export const saveVideoToGallery = async (videoData: {
  file: File
  url: string
  duration: number
  cloudinaryPublicId?: string
  cloudinaryUrl?: string
}): Promise<GalleryVideo> => {
  const newVideo: GalleryVideo = {
    id: `video_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    name: videoData.file.name,
    thumbnail: videoData.cloudinaryUrl 
      ? `https://res.cloudinary.com/dyqjxsnjp/video/upload/so_2.0,w_300,h_200,c_fill,q_auto,f_jpg/${videoData.cloudinaryPublicId}.jpg`
      : videoData.url,
    duration: videoData.duration,
    size: formatFileSize(videoData.file.size),
    uploadedAt: new Date(),
    file: videoData.file,
    url: videoData.cloudinaryUrl || videoData.url,
    cloudinaryPublicId: videoData.cloudinaryPublicId,
    cloudinaryUrl: videoData.cloudinaryUrl
  }

  // ‚úÖ TENTAR SALVAR NO SUPABASE PRIMEIRO
  try {
    const { data: { user } } = await supabase.auth.getUser()
    if (!user) {
      console.warn('‚ùå Usu√°rio n√£o autenticado - salvando apenas no localStorage')
      return saveVideoToLocalStorage(newVideo)
    }

    // üé≠ DETEC√á√ÉO DE AMBIENTE PLAYWRIGHT - N√ÉO AFETA PRODU√á√ÉO
    const isPlaywrightTest = typeof window !== 'undefined' && (
      (window as any).__playwright === true ||
      (window as any).__isTestEnvironment === true ||
      window.navigator.userAgent.includes('HeadlessChrome') ||
      window.navigator.webdriver === true ||
      process.env.NODE_ENV === 'test' ||
      typeof (window as any).playwright !== 'undefined'
    )

    let insertData: any = {
      id: newVideo.id,
      user_id: user.id,
      filename: newVideo.name,
      size: videoData.file.size, // Bytes reais
      status: 'uploaded',
      storage_path: newVideo.cloudinaryUrl || newVideo.url
      // created_at ser√° gerado automaticamente pelo Supabase
    }

    // üè≠ PRODU√á√ÉO: Usar duration normalmente (como estava funcionando)
    if (!isPlaywrightTest) {
      insertData.duration = newVideo.duration
      console.log('üè≠ PRODU√á√ÉO: Incluindo duration no insert:', insertData.duration)
    } else {
      // üß™ PLAYWRIGHT: Tentar com duration, se falhar, continuar sem
      console.log('üé≠ Ambiente Playwright detectado - usando estrat√©gia de teste')
      console.log('üé≠ Detec√ß√£o baseada em:', {
        __playwright: (window as any).__playwright,
        __isTestEnvironment: (window as any).__isTestEnvironment,
        userAgent: window.navigator.userAgent,
        webdriver: window.navigator.webdriver,
        nodeEnv: process.env.NODE_ENV
      })
      
      try {
        insertData.duration = newVideo.duration
        console.log('üé≠ Playwright: Tentando com duration:', insertData.duration)
      } catch (e) {
        console.warn('üé≠ Playwright: Removendo duration para evitar erro PGRST204')
        delete insertData.duration
      }
    }

    const { error } = await supabase
      .from('videos')
      .insert(insertData)

    if (error) {
      console.error('‚ùå Erro ao salvar v√≠deo no Supabase:', error)
      
      // üé≠ PLAYWRIGHT: Se erro PGRST204 (coluna n√£o encontrada), tentar sem duration
      if (isPlaywrightTest && error.code === 'PGRST204' && insertData.duration !== undefined) {
        console.log('üé≠ Playwright: Erro PGRST204 detectado, tentando novamente SEM coluna duration...')
        console.log('üé≠ Insert data original:', JSON.stringify(insertData, null, 2))
        
        const insertDataWithoutDuration = { ...insertData }
        delete insertDataWithoutDuration.duration
        
        console.log('üé≠ Insert data sem duration:', JSON.stringify(insertDataWithoutDuration, null, 2))
        
        const { error: retryError } = await supabase
          .from('videos')
          .insert(insertDataWithoutDuration)
        
        if (!retryError) {
          console.log('‚úÖ Playwright: Sucesso ao salvar SEM duration!')
          // Salvar tamb√©m no localStorage para backup
          saveVideoToLocalStorage(newVideo)
          return newVideo
        } else {
          console.error('‚ùå Playwright: Falha mesmo sem duration:', retryError)
        }
      }
      
      console.log('üîÑ Salvando no localStorage como fallback...')
      return saveVideoToLocalStorage(newVideo)
    }

    console.log('‚òÅÔ∏è V√≠deo salvo no Supabase (100% REAL):', newVideo.name)
    
    // Salvar tamb√©m no localStorage para backup
    saveVideoToLocalStorage(newVideo)
    
    return newVideo
  } catch (error) {
    console.error('‚ùå Erro ao salvar v√≠deo no Supabase:', error)
    console.log('üîÑ Salvando no localStorage como fallback...')
    return saveVideoToLocalStorage(newVideo)
  }
}

// ‚úÖ Fun√ß√£o para obter v√≠deos do Supabase (100% REAL) com fallback
export const getGalleryVideos = async (): Promise<GalleryVideo[]> => {
  try {
    const { data: { user } } = await supabase.auth.getUser()
    if (!user) {
      console.warn('‚ö†Ô∏è Usu√°rio n√£o autenticado - usando localStorage como fallback')
      return getGalleryVideosFromLocalStorage()
    }

    const { data: videos, error } = await supabase
      .from('videos')
      .select('*')
      .eq('user_id', user.id)
      .order('created_at', { ascending: false })

    if (error) {
      console.error('‚ùå Erro ao carregar v√≠deos do Supabase:', error)
      console.log('üîÑ Tentando localStorage como fallback...')
      return getGalleryVideosFromLocalStorage()
    }

    if (!videos || videos.length === 0) {
      console.log('üìÅ Nenhum v√≠deo encontrado no Supabase')
      // Verificar se h√° v√≠deos no localStorage
      const localVideos = getGalleryVideosFromLocalStorage()
      if (localVideos.length > 0) {
        console.log(`üìÅ Encontrados ${localVideos.length} v√≠deos no localStorage`)
        return localVideos
      }
      return []
    }

    const galleryVideos: GalleryVideo[] = videos.map(video => {
      // Extrair public_id do storage_path para thumbnail
      let publicId = ''
      if (video.storage_path) {
        const matches = video.storage_path.match(/\/([^\/]+)\.mp4$/)
        publicId = matches ? matches[1] : ''
      }

      return {
        id: video.id,
        name: video.filename,
        thumbnail: publicId 
          ? `https://res.cloudinary.com/dyqjxsnjp/video/upload/so_2.0,w_300,h_200,c_fill,q_auto,f_jpg/${publicId}.jpg`
          : video.storage_path || '',
        duration: video.duration || 0,
        size: formatFileSize(video.size || 0),
        uploadedAt: new Date(video.created_at),
        url: video.storage_path,
        cloudinaryUrl: video.storage_path,
        cloudinaryPublicId: publicId
      }
    })

    console.log(`‚òÅÔ∏è ${galleryVideos.length} v√≠deos carregados do Supabase (100% REAL)`)
    return galleryVideos
  } catch (error) {
    console.error('‚ùå Erro ao carregar v√≠deos do Supabase:', error)
    console.log('üîÑ Usando localStorage como fallback...')
    return getGalleryVideosFromLocalStorage()
  }
}

// ‚úÖ Fun√ß√£o de fallback para localStorage
const getGalleryVideosFromLocalStorage = (): GalleryVideo[] => {
  try {
    const stored = localStorage.getItem('clipsforge_gallery_videos')
    if (!stored) return []
    
    const videos = JSON.parse(stored)
    return videos.map((video: any) => ({
      ...video,
      uploadedAt: new Date(video.uploadedAt)
    }))
  } catch (error) {
    console.error('‚ùå Erro ao carregar v√≠deos do localStorage:', error)
    return []
  }
}

// ‚úÖ Fun√ß√£o para excluir v√≠deo do Supabase (100% REAL)
export const deleteVideoFromGallery = async (videoId: string): Promise<void> => {
  try {
    const { data: { user } } = await supabase.auth.getUser()
    if (!user) {
      console.error('‚ùå Usu√°rio n√£o autenticado')
      return
    }

    const { error } = await supabase
      .from('videos')
      .delete()
      .eq('id', videoId)
      .eq('user_id', user.id) // Seguran√ßa: s√≥ deletar pr√≥prios v√≠deos

    if (error) {
      console.error('‚ùå Erro ao excluir v√≠deo do Supabase:', error)
      throw error
    }

    console.log('‚òÅÔ∏è V√≠deo exclu√≠do do Supabase (100% REAL):', videoId)
  } catch (error) {
    console.error('‚ùå Erro ao excluir v√≠deo:', error)
    throw error
  }
}

// Fun√ß√£o utilit√°ria para formatar tamanho do arquivo
const formatFileSize = (bytes: number): string => {
  if (bytes === 0) return '0 Bytes'
  
  const k = 1024
  const sizes = ['Bytes', 'KB', 'MB', 'GB']
  const i = Math.floor(Math.log(bytes) / Math.log(k))
  
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i]
}

// ‚úÖ FUN√á√ïES DE TRANSCRI√á√ÉO (mantidas para compatibilidade)
export const saveTranscriptionToGallery = (videoId: string, data: {
  transcription: string
  words?: any[]
  provider?: 'whisper' | 'assemblyai' | 'webspeech'
}): boolean => {
  // Log reduzido - apenas em desenvolvimento
  const cacheKey = `save_${videoId}`
  if (!transcriptionCache.has(cacheKey)) {
    if (process.env.NODE_ENV === 'development') {
      console.log('üìù saveTranscriptionToGallery: Migrado para Supabase')
    }
    transcriptionCache.set(cacheKey, true)
  }
  return false
}

// Cache para hasTranscription para evitar warnings repetitivos
const transcriptionCache = new Map<string, boolean>()
const cacheExpiry = new Map<string, number>()
const CACHE_DURATION = 60000 // 1 minuto

export const hasTranscription = (videoId: string): boolean => {
  // Verificar cache primeiro para evitar logs repetitivos
  if (transcriptionCache.has(videoId)) {
    const expiry = cacheExpiry.get(videoId) || 0
    if (Date.now() < expiry) {
      return transcriptionCache.get(videoId) || false
    }
    // Cache expirado, remover
    transcriptionCache.delete(videoId)
    cacheExpiry.delete(videoId)
  }

  // Log reduzido - apenas primeira vez por video
  if (!transcriptionCache.has(videoId)) {
    // Log silencioso para produ√ß√£o - s√≥ mostra se em modo debug
    if (process.env.NODE_ENV === 'development') {
      console.log(`üìù hasTranscription(${videoId}): Migrado para Supabase`)
    }
  }
  
  // Cachear resultado para evitar futuros logs
  transcriptionCache.set(videoId, false)
  cacheExpiry.set(videoId, Date.now() + CACHE_DURATION)
  
  // Sempre retorna false (migrado para Supabase)
  return false
}

export const getTranscriptionFromGallery = (videoId: string) => {
  // Log reduzido - apenas em desenvolvimento
  const cacheKey = `get_${videoId}`
  if (!transcriptionCache.has(cacheKey)) {
    if (process.env.NODE_ENV === 'development') {
      console.log('üìù getTranscriptionFromGallery: Migrado para Supabase')
    }
    transcriptionCache.set(cacheKey, true)
  }
  return null
}

export const saveOriginalCaptions = (videoId: string, captions: TranscriptionWord[]): boolean => {
  // Log reduzido - apenas em desenvolvimento
  const cacheKey = `captions_${videoId}`
  if (!transcriptionCache.has(cacheKey)) {
    if (process.env.NODE_ENV === 'development') {
      console.log('üìù saveOriginalCaptions: Migrado para Supabase')
    }
    transcriptionCache.set(cacheKey, true)
  }
  return false
}

export const saveEditedCaptions = (videoId: string, editedCaptions: TranscriptionWord[]): boolean => {
  console.warn('‚ö†Ô∏è saveEditedCaptions: Fun√ß√£o localStorage removida - usar Supabase')
  return false
}

export const getOriginalCaptions = (videoId: string): TranscriptionWord[] | null => {
  console.warn('‚ö†Ô∏è getOriginalCaptions: Fun√ß√£o localStorage removida - usar Supabase')
  return null
}

export const getEditedCaptions = (videoId: string): TranscriptionWord[] | null => {
  console.warn('‚ö†Ô∏è getEditedCaptions: Fun√ß√£o localStorage removida - usar Supabase')
  return null
}

export const hasEditedCaptions = (videoId: string): boolean => {
  console.warn('‚ö†Ô∏è hasEditedCaptions: Fun√ß√£o localStorage removida - usar Supabase')
  return false
}

export const resetToOriginalCaptions = (videoId: string): boolean => {
  console.warn('‚ö†Ô∏è resetToOriginalCaptions: Fun√ß√£o localStorage removida - usar Supabase')
  return false
}

// ‚úÖ Fun√ß√£o de fallback para salvar no localStorage
const saveVideoToLocalStorage = (newVideo: GalleryVideo): GalleryVideo => {
  try {
    const existingVideos = getGalleryVideosFromLocalStorage()
    const updatedVideos = [newVideo, ...existingVideos]
    const limitedVideos = updatedVideos.slice(0, 50)
    
    localStorage.setItem('clipsforge_gallery_videos', JSON.stringify(limitedVideos.map(video => ({
      ...video,
      uploadedAt: video.uploadedAt.toISOString(),
      file: undefined // N√£o salvar o File object
    }))))
    
    console.log('üíæ V√≠deo salvo no localStorage como fallback:', newVideo.name)
    return newVideo
  } catch (error) {
    console.error('‚ùå Erro ao salvar v√≠deo no localStorage:', error)
    throw error
  }
}

// ‚úÖ MANTER FUN√á√ÉO PARA COMPATIBILIDADE (mas agora aponta para Supabase)
export const syncGalleryWithSupabase = async (): Promise<void> => {
  console.log('üîÑ Sistema agora √© 100% Supabase - sync desnecess√°rio')
}

// ‚úÖ CLIPS - Mantido para compatibilidade (localStorage tempor√°rio)
const GALLERY_CLIPS_KEY = 'clipsforge_gallery_clips'

// Fun√ß√£o para salvar clip na galeria
export const saveClipToGallery = (clipData: Omit<GalleryClip, 'id' | 'createdAt'>): GalleryClip => {
  const newClip: GalleryClip = {
    ...clipData,
    id: `clip_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    createdAt: new Date()
  }

  const existingClips = getGalleryClips()
  const updatedClips = [newClip, ...existingClips].slice(0, 15) // Limitar a 15 clips
  
  try {
    localStorage.setItem(GALLERY_CLIPS_KEY, JSON.stringify(updatedClips.map(clip => ({
      ...clip,
      createdAt: clip.createdAt.toISOString()
    }))))
    
    // Clip salvo na galeria
  } catch (error) {
    console.error('‚ùå Erro ao salvar clip na galeria:', error)
  }
  
  return newClip
}

// Fun√ß√£o para obter clips da galeria
export const getGalleryClips = (): GalleryClip[] => {
  try {
    const stored = localStorage.getItem(GALLERY_CLIPS_KEY)
    if (!stored) return []
    
    const clips = JSON.parse(stored)
    return clips.map((clip: any) => ({
      ...clip,
      createdAt: new Date(clip.createdAt)
    }))
  } catch (error) {
    console.error('‚ùå Erro ao carregar clips da galeria:', error)
    return []
  }
}

// Fun√ß√£o para excluir clip da galeria
export const deleteClipFromGallery = (clipId: string): void => {
  try {
    const existingClips = getGalleryClips()
    const updatedClips = existingClips.filter(clip => clip.id !== clipId)
    
    localStorage.setItem(GALLERY_CLIPS_KEY, JSON.stringify(updatedClips.map(clip => ({
      ...clip,
      createdAt: clip.createdAt.toISOString()
    }))))
    
    // Clip exclu√≠do da galeria
  } catch (error) {
    console.error('‚ùå Erro ao excluir clip da galeria:', error)
  }
} 